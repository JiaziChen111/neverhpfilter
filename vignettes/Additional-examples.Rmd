---
title: "Additional examples"
author: "Justin M Shea"
date: ' '
output:
  rmarkdown::html_document:
    toc: yes
vignette: >
  %\VignetteIndexEntry{Additional examples}  
  %\VignetteEngine{knitr::rmarkdown}  
  %\VignetteEncoding{UTF-8}
---


```{r, message = FALSE, warning = FALSE}
library(xts)
library(knitr)
library(neverhpfilter)
```


## yth_glm

The `yth_glm` function returns an object of class "`glm`". Thus, one can use all
generic functions associated with objects of that class. Here is an example of
passing the `yth_glm` model to the plot function.

```{r, warning=FALSE, message=FALSE}
data(GDPC1)
log_RGDP <- 100*log(GDPC1)

gdp_model <- yth_glm(log_RGDP, h = 8, p = 4)

plot(gdp_model)
```

Additional parameters supported by the `glm` function can be used as well. An example ussing a different error distribution, defined with the `family` argument, is illustrated below.

```{r, warning=FALSE, message=FALSE}
gdp_poisson <- yth_glm(log_RGDP["1950/"], h = 8, p = 4, family = quasipoisson)

summary(gdp_poisson)
```


In addition to all generic functions inherited in base R, one can also use any package 
designed to work with model objects.

```{r, warning=FALSE, message=FALSE}
library(broom)
gdp_model_df <- broom::tidy(gdp_model)

kable(gdp_model_df)
```

## yth_filtered

The function outputs an xts object of all series discussed in Hamilton.
They are the original series, trend, cycle, and random walk.

```{r, warning = FALSE, message = FALSE}
gdp_filtered <- yth_filter(log_RGDP, h = 8, p = 4)

kable(tail(gdp_filtered, 8))
```

Because the output an xts object, it can be easily graphed with `plot.xts` with a simple function call. Note the `panels` arguement, which we used to plot bars of the cycle.

```{r, warning = FALSE}
main <- "Log of Real GDP (GDPC1) and trend"
plot(gdp_filtered[,1:2], grid.col = "white", legend.loc = "topleft", main = main,  panels = 'lines(gdp_filtered[,3], type="h", on=NA)')
```

In addition, many packages recognize xts objects such as `PerformanceAnalytics`.
Recession bars are created easily by the `period.areas` arguement of the `chart.TimeSeries` function.

```{r, warning = FALSE, message = FALSE}
library(PerformanceAnalytics)

  qtr_recc <- to.quarterly(USREC["1947-1/2017-3"], OHLC=FALSE)
     start <- index(qtr_recc[which(diff(qtr_recc$USREC)==1)])
       end <- index(qtr_recc[which(diff(qtr_recc$USREC)==-1)])
Recessions <- paste(format(start,"%Y-%q"), format(end,"%Y-%q"), sep="/")

main <- "Log of Real GDP (GDPC1) and trend"
chart.TimeSeries(gdp_filtered[,1:2], main = main, period.areas = Recessions, period.color="lightgrey", lwd=2)
```

```{r, warning = FALSE}
main <- "Log of Real GDP cycle and random walk"
plot(gdp_filtered[,3:4], subset = "1982/", grid.col = "white", legend.loc = "topright", main = main)
#lines(panel.first = abline(v = .index(qtr_recc2), type="h", lwd = 2, col = "lightgrey"))
#addSeries(x = .index(qtr_recc2), type="h", lwd = 2, col = "lightgrey")

```

## yth_cycle

While Hamilton converts the PAYEMS series into quarterly periodicity and then uses
the default parameters of `h = 8` and `p = 4`, one can choose to retain the monthly series and adjust the parameters to `h = 24` and `p = 12`. This approach removes the parsimony associated with estimating a linear model on 4 lags, as now one will have 12. 

```{r, warning = FALSE}
Employment_log <- 100*log(PAYEMS["1947/"])

employment_cycle <- yth_filter(Employment_log, h = 24, p = 12, output = "cycle")

main <- "Absolute Log of Employment cycle"
plot(abs(employment_cycle), grid.col = "white", main = main)
```


